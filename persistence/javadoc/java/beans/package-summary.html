<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Jan 18 17:24:16 PST 2001 -->
<TITLE>
: Package java.beans
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<H2>
Package java.beans
</H2>
Contains classes related to Java Beans development.
<P>
<B>See: </B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Interface Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="ExceptionListener.html"><I>ExceptionListener</I></A></B></TD>
<TD>An ExceptionListener is notified of internal exceptions.</TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="DefaultPersistenceDelegate.html">DefaultPersistenceDelegate</A></B></TD>
<TD>The <code>DefaultPersistenceDelegate</code> is a concrete implementation of 
 the abstract <code>PersistenceDelegate</code> class and 
 is the delegate used by default for classes about 
 which no information is available.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="Encoder.html">Encoder</A></B></TD>
<TD>An <code>Encoder</code> is a class which can be used to create 
 files or streams that encode the state of a collection of 
 JavaBeans in terms of their public APIs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="EventHandler.html">EventHandler</A></B></TD>
<TD>The <code>EventHandler</code> class provides 
 support for dynamically generating event listeners whose methods
 execute a simple statement involving the incoming event object
 and a target object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="Expression.html">Expression</A></B></TD>
<TD>An <code>Expression</code> object represents a primitive expression 
 in which a single method is applied to a target and a set of 
 arguments to return a result - as in <code>"a.getFoo()"</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="PersistenceDelegate.html">PersistenceDelegate</A></B></TD>
<TD>The PersistenceDelegate class takes the responsibility 
 for expressing the state of an instance of a given class 
 in terms of the methods in the class's public API.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="Statement.html">Statement</A></B></TD>
<TD>A <code>Statement</code> object represents a primitive statement 
 in which a single method is applied to a target and 
 a set of arguments - as in <code>"a.setFoo(b)"</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="XMLDecoder.html">XMLDecoder</A></B></TD>
<TD>The <code>XMLDecoder</code> class is used to read XML documents 
 created using the <code>XMLEncoder</code> and is used just like 
 the <code>ObjectInputStream</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="XMLEncoder.html">XMLEncoder</A></B></TD>
<TD>The <code>XMLEncoder</code> class is a complementary alternative to 
 the <code>ObjectOutputStream</code> and can used to generate  
 a textual representation of a <em>JavaBean</em> in the same 
 way that the <code>ObjectOutputStream</code> can 
 be used to create binary representation of <code>Serializable</code> 
 objects.</TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A><H2>
Package java.beans Description
</H2>

<P>
Contains classes related to Java Beans development. A few of the
classes are used by beans while they run in an application. 
For example, the event classes are
used by beans that fire property and vetoable change 
events (see PropertyChangeEvent). However, most of the classes in this
package are meant to be used by a bean editor (that is, a development environment 
for customizing and putting together beans to create an application). In
particular, these classes help the bean editor create a user 
interface that the user can use to customize the bean. For example, a bean may 
contain a property of a special type that a bean editor may not know how to handle. 
By using the PropertyEditor interface, a bean developer can
provide an editor for this special type.
<p>
To minimize the resources used by a bean, the classes used by bean editors are loaded only
when the bean is being edited. They are not needed while the bean is running in an application
and therefore not loaded. This information is kept in what's called a bean-info (see BeanInfo).
<!--
<h2>Package Specification</h2>

##### FILL IN ANY SPECS NEEDED BY JAVA COMPATIBILITY KIT #####
<ul>
  <li><a href="">##### REFER TO ANY FRAMEMAKER SPECIFICATION HERE #####</a>
</ul>

<h2>Related Documentation</h2>

For overviews, tutorials, examples, guides, and tool documentation, please see:
<ul>
  <li><a href="">##### REFER TO NON-SPEC DOCUMENTATION HERE #####</a>
</ul>
-->
<p>
<!-- @since JDK1.1 -->
<p>
<h2>Long-term Persistence for JavaBeans</h2>
The new APIs in the java.beans package provide support for reading and
writing a <i>JavaBean</i> as a textual representation of its property values.
When these property values are themselves <i>JavaBean</i>s the process
is called recursively to record the publicly available state of an entire
graph of JavaBeans.
<h3>
Goals</h3>
The following goals were established for creating a long term persistence
scheme for <i>JavaBean</i>s:
<ul>
<li>
Resilience to changes in the versions of both VMs and class libraries.</li>

<li>
Fault tolerance, allowing an archive to load even when&nbsp; part of it
is damaged.</li>

<li>
Textual (XML) output that can be edited with standard tools.</li>

<li>
Comprehensive use of defaults (redundancy elimination) to minimize file
size.</li>

<li>
Performance that varies linearly with the number of nodes in the graph.</li>

<li>
Class-specific "serialization" code should be independent of the encoding.</li>
</ul>

<blockquote>
<h4>

<hr></h4>

<h4>
A Note on Marshaling vs. Archiving</h4>
There are two main tacks to take in persistence schemes:
<ul>
<li>
Recording all state in an object graph, including non-public state.</li>

<li>
Recording all state that can be reconstituted using the public APIs of
the objects in the graph.</li>
</ul>
The simplest scheme taking the first approach requires the inclusion of
all the classes that define the objects -- which is too expensive. The
practical alternative, which is to refrain from serializing the byte codes
that define the classes themselves, is workable between identical implementations
of the same libraries. The serialization framework in 1.1 implements this
and is therefore the method of choice for sending faithful copies of an
object graph between two similar VMs.
<p>In this work we implement the second approach&nbsp; - which cannot produce
as faithful a copy of the original objects as the first but can store the
state of the graph in such a way that any virtual machine with API-compatible
implementations of the classes involved will be sufficient to reconstitute
it. Since APIs are so much more stable than their private implementations,
this single step virtually solves the versioning issues for most practical
purposes. As importantly, from an deployment perspective, the behavior
of the constructors residing on the client machine can be leveraged, often
dramatically reducing the size of the files that need to be transferred.
<p>
<hr></blockquote>

<h3>
The Persistence Model</h3>
The new streams read and write archives that depend only on the public
APIs of the <i>JavaBean</i>s in the archive, and not on the state of any
private implementation. Like modern programming languages, the implementation
of the new streams deals with the syntactic and semantic elements of this
task separately. This formal separation allows the majority of the internal
architecture, and any special-case code that changes the way the state
of a particular class is archived, to be written in a form that is independent
of the syntax of the output.&nbsp; Given both the proliferation of new
XML standards and their rapid evolution, this accommodating rather than
defining role seems to be the best way to provide JavaBeans with a long-term
persistence strategy that can coexist with this evolutionary process.
<p>Typically this architecture reduces the serialization problem for JavaBeans
to the problem of providing an ordered list of properties that define the
state of the JavaBean. All values of the properties of a JavaBean are assumed
to be JavaBeans. To make this recursive definition work, we have to widen
the notion of what is considered a JavaBean slightly so as to include all
possible values that properties can take. In our implementation, <tt>Color</tt>
objects are considered to be JavaBeans, as are <tt>LayoutManager</tt>s,
<tt>Vector</tt>s,
<tt>Hashtables</tt>,
<tt>Number</tt>s,
and <tt>Boolean</tt> values. To handle the "wiring" part of the user interface
it has also proven convenient to provide built-in support for some other
key classes in the JDK including
<tt>Method</tt>,
<tt>Class</tt>, array
classes, and proxy classes.
<p>To handle all these extra classes the first requirement is that we are
able to create instances of them. In all the special cases, where no nullary
constructor is defined, this requires extra information that describes
how a new instance should be created. For most classes this extra information
simply associates the arguments of a chosen constructor with names of the
properties they represent. So, for example, the <tt>java.awt.Color</tt>
class is augmented with <i>meta data</i> recording the fact that the three
integers that appear as arguments in one of the constructors are the <i>red</i>,
<i>green</i>,
and <i>blue</i> properties of the new instance. Given this extra information
the recording of a <tt>Color</tt> object is reduced to the simpler problem
of recording the <tt>Integer</tt> values of those properties.
<p>In other cases, such as <tt>java.lang.Method</tt>, the extra information
is used to indicate to the output stream the fact that, instead of using
a constructor, the static <tt>getMethod</tt> method in <tt>java.lang.Class</tt>
should be used to retrieve instances of the <tt>Method</tt> class. Near
the bottom of these recursive definitions are the wrappers for the primitive
types of the Java virtual machine: the <tt>Boolean</tt> class and the <tt>Number</tt>
derivatives. All of these classes have a useful invariant in that they
may be reconstructed by calling their single-argument constructor using
the value returned by the <tt>toString</tt> method.&nbsp; Closing this
recursive definition then, is the <tt>java.lang.String</tt> class, for
which each file format must provide built-in support, and in terms of which
all other objects will be represented.
<p>In addition to the need to be able to specify the manner in which an
object should be instantiated it is also necessary to find a general way
to describe the way it should be initialized. This allows the user to accommodate
"hidden state" which is not represented as properties but which is central
to the public behavior of an object. An instance of the <i>java.awt.Container
</i>class,
for example, should have all of its children recorded if it is expected
to behave like the original.
<h4>
Architecture</h4>
Critical to dealing with these special cases and providing a means by which
the application programmer can provide their own persistence for new JavaBeans
with similar anomalies are two new public classes in the beans package:
the <i>Expression</i> and the <i>Statement</i>. Both of these new classes
present simple abstractions of the single-method <i>expressions</i> and
<i>statements
</i>that
one might expect to find in a java source program. The new output stream
works by providing an architecture in which the object graph is cloned
- exclusively by using <i>Expression</i> and <i>Statement</i> objects in
a new environment. If this cloning process is successful, a record of the
<i>Expressions</i> and <i>Statements</i> used to duplicate the object graph
may be encoded into a textual format and put in a file which is then capable
of creating the object graph on its own.
<h4>
Identity</h4>
As the object graph is traversed a hashtable (actually a special kind of
hashtable that uses "<tt>==</tt>" instead of "<tt>equals</tt>") is used
to detect when a node is revisited. When it is, the stream gives this instance
a name so that it can be referred to multiple times in the archive. That
way the <i>identity</i> of objects in the graph is preserved by the archival
process.
<h4>
Size</h4>
Even though an XML encoding, term for term, takes significantly more space
than a binary encoding, the archives produced by the new streams are typically
between 10x and 100x <i>smaller</i> than their serialized counterparts.
This is due to a comprehensive system for excluding default information
from the archives.
<h4>
Listeners</h4>
A crucial part of a user interface, beyond the way it will appear, is the
way it will be connected to the logic of an application. In the past this
has only been possible by generating Java source files that implement event
listener interfaces and compiling&nbsp; them at design time. With the introduction
of the <tt>java.lang.reflect.Proxy</tt> API's in SDK 1.3 it is now possible
to consider the "wiring" of the user interface as part of the state of
the design and saved as an integral part of archive that represents it.
<p>The new <tt>EventHandler</tt> class provides a convenient and concise
way to make use of the Proxy APIs to create listeners for JavaBeans. Most
importantly, this "trampoline" class has both a public constructor and
accessors for all internal state that is required to produce it. Such classes,
unlike anonymous inner classes, can therefore be archived in the same way
that any other bean is archived: as a textual representation of the public
API needed to create it.
<h3>
Summary</h3>
The new input and output streams complement the binary serialization support
that was introduced in JDK 1.1 with support for a human readable format.
The new streams have been implemented to a set of design goals that make
them more suitable than binary serialization as a persistence mechanism
for user interfaces. Committing the archives to the public APIs of the
classes to which they refer makes the archives inherently more robust than
those that contain private state. The redundancy elimination system used
in the new streams makes the new formats attractive in that they are both
human-readable and, in most cases, one or two orders of magnitude smaller
than their binary equivalents.
<p>
<!-- @since 1.4 -->
<P>
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Package</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV PACKAGE&nbsp;
&nbsp;NEXT PACKAGE</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="package-summary.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
