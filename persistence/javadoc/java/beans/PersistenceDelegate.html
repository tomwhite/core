<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Jan 18 17:24:18 PST 2001 -->
<TITLE>
: Class  PersistenceDelegate
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/beans/Expression.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../java/beans/Statement.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PersistenceDelegate.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.beans</FONT>
<BR>
Class  PersistenceDelegate</H2>
<PRE>
java.lang.Object
  |
  +--<B>java.beans.PersistenceDelegate</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../java/beans/DefaultPersistenceDelegate.html">DefaultPersistenceDelegate</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>PersistenceDelegate</B><DT>extends java.lang.Object</DL>

<P>
The PersistenceDelegate class takes the responsibility 
 for expressing the state of an instance of a given class 
 in terms of the methods in the class's public API. Instead 
 of associating the responsibility of persistence with 
 the class itself as is done, for example, by the 
 <code>readObject</code> and <code>writeObject</code> 
 methods used by the <code>ObjectOutputStream</code>, streams like 
 the <code>XMLEncoder</code> which 
 use this delegation model can have their behavior controlled 
 independently of the classes themselves. Normally, the class  
 is the best place to put such information and conventions 
 can easily be expressed in this delegation scheme to do just that. 
 Sometimes however, it is the case that a minor problem 
 in a single class prevents an entire object graph from 
 being written and this can leave the application 
 developer with no recourse but to attempt to shadow  
 the problematic classes locally or use alternative 
 persistence techniques. In situations like these, the 
 delegation model gives a relatively clean mechanism for 
 the application developer to intervene in all parts of the 
 serialization process without requiring that modifications   
 be made to the implementation of classes which are not part 
 of the application itself.  
 <p>
 In addition to using a delegation model, this persistence 
 scheme differs from traditional serialization schemes 
 in requiring an analog of the <code>writeObject</code> 
 method without a corresponding <code>readObject</code> 
 method. The <code>writeObject</code> analog encodes each 
 instance in terms of its public API and there is no need to  
 define a <code>readObject</code> analog   
 since the procedure for reading the serialized form 
 is defined by the semantics of method invocation as laid 
 out in the Java Language Specification. 
 Breaking the dependency between <code>writeObject</code> 
 and <code>readObject</code> implementations, which may  
 change from version to version, is the key factor   
 in making the archives produced by this technique immune  
 to changes in the private implementations of the classes 
 to which they refer. 
 <p>
 A persistence delegate, may take control of all 
 aspects of the persistence of an object including: 
 <ul>
 <li>
 Deciding whether or not an instance can be mutated 
 into another instance of the same class. 
 <li>
 Instantiating the object, either by calling a 
 public constructor or a public factory method. 
 <li>
 Performing the initialization of the object. 
 </ul>
<P>
<DL>
<DT><B>Since: </B><DD>1.4</DD>
<DT><B>See Also: </B><DD><A HREF="../../java/beans/XMLEncoder.html"><CODE>XMLEncoder</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/beans/PersistenceDelegate.html#PersistenceDelegate()">PersistenceDelegate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/beans/PersistenceDelegate.html#initialize(java.lang.Class, java.lang.Object, java.lang.Object, java.beans.Encoder)">initialize</A></B>(java.lang.Class&nbsp;type,
           java.lang.Object&nbsp;oldInstance,
           java.lang.Object&nbsp;newInstance,
           <A HREF="../../java/beans/Encoder.html">Encoder</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produce a series of statements with side effects on <code>newInstance</code> 
 so that the new instance becomes <em>equivalent</em> to <code>oldInstance</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../java/beans/Expression.html">Expression</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/beans/PersistenceDelegate.html#instantiate(java.lang.Object, java.beans.Encoder)">instantiate</A></B>(java.lang.Object&nbsp;oldInstance,
            <A HREF="../../java/beans/Encoder.html">Encoder</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an expression whose value is <code>oldInstance</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/beans/PersistenceDelegate.html#mutatesTo(java.lang.Object, java.lang.Object)">mutatesTo</A></B>(java.lang.Object&nbsp;oldInstance,
          java.lang.Object&nbsp;newInstance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if an <em>equivalent</em> copy of <code>oldInstance</code> may be 
 created by applying a series of statements to <code>newInstance</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/beans/PersistenceDelegate.html#writeObject(java.lang.Object, java.beans.Encoder)">writeObject</A></B>(java.lang.Object&nbsp;oldInstance,
            <A HREF="../../java/beans/Encoder.html">Encoder</A>&nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>writeObject</code> is a single entry point to the persistence 
 and is used by a <code>Encoder</code> in the traditional 
 mode of delegation.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="PersistenceDelegate()"><!-- --></A><H3>
PersistenceDelegate</H3>
<PRE>
public <B>PersistenceDelegate</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="writeObject(java.lang.Object, java.beans.Encoder)"><!-- --></A><H3>
writeObject</H3>
<PRE>
public void <B>writeObject</B>(java.lang.Object&nbsp;oldInstance,
                        <A HREF="../../java/beans/Encoder.html">Encoder</A>&nbsp;out)</PRE>
<DL>
<DD>The <code>writeObject</code> is a single entry point to the persistence 
 and is used by a <code>Encoder</code> in the traditional 
 mode of delegation. Although this method is not final, 
 it should not need to be subclassed under normal circumstances. 
 <p> 
 This implementation first checks to see if the stream 
 has already encountered this object. Next the 
 <code>mutatesTo</code> method is called to see if 
 that candidate returned from the stream can 
 be mutated into an accurate copy of <code>oldInstance</code>. 
 If it can, the <code>initialize</code> method is called to 
 perform the initialization. If not, the candidate is removed 
 from the stream, and the <code>instantiate</code> method 
 is called to create a new candidate for this object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldInstance</CODE> - The instance that will be created by this expression.<DD><CODE>out</CODE> - The stream to which this expression will be written.<DT><B>Returns:</B><DD>An expression whose value is <code>oldInstance</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="mutatesTo(java.lang.Object, java.lang.Object)"><!-- --></A><H3>
mutatesTo</H3>
<PRE>
protected boolean <B>mutatesTo</B>(java.lang.Object&nbsp;oldInstance,
                            java.lang.Object&nbsp;newInstance)</PRE>
<DL>
<DD>Returns true if an <em>equivalent</em> copy of <code>oldInstance</code> may be 
 created by applying a series of statements to <code>newInstance</code>. 
 In the specification of this method, we mean by equivalent that the modified instance 
 is indistinguishable from <code>oldInstance</code> in the behavior 
 of the relevant methods in its public API. [Note: we use the  
 phrase <em>relevant</em> methods rather than <em>all</em> methods 
 here only because, to be strictly correct, methods like <code>hashCode</code> 
 and <code>toString</code> prevent most classes from producing truly 
 indistinguishable copies of their instances]. 
 <p>
 The default behavior returns <code>true</code> 
 if the classes of the two instances are the same.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldInstance</CODE> - The instance to be copied.<DD><CODE>newInstance</CODE> - The instance that is to be modified.<DT><B>Returns:</B><DD>True if an equivalent copy of <code>newInstance</code> may be 
         created by applying a series of mutations to <code>oldInstance</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="instantiate(java.lang.Object, java.beans.Encoder)"><!-- --></A><H3>
instantiate</H3>
<PRE>
protected abstract <A HREF="../../java/beans/Expression.html">Expression</A> <B>instantiate</B>(java.lang.Object&nbsp;oldInstance,
                                          <A HREF="../../java/beans/Encoder.html">Encoder</A>&nbsp;out)</PRE>
<DL>
<DD>Returns an expression whose value is <code>oldInstance</code>. 
 This method is used to characterize the constructor 
 or factory method that should be used to create the given object. 
 For example, the <code>instantiate</code> method of the persistence 
 delegate for the <code>Field</code> class could be defined as follows: 
 <pre>
 Field f = (Field)oldInstance;
 return new Expression(f, f.getDeclaringClass(), "getField", new Object[]{f.getName()});
 </pre> 
 Note that we declare the value of the returned expression so that 
 the value of the expression (as returned by <code>getValue</code>) 
 will be identical to <code>oldInstance</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldInstance</CODE> - The instance that will be created by this expression.<DD><CODE>out</CODE> - The stream to which this expression will be written.<DT><B>Returns:</B><DD>An expression whose value is <code>oldInstance</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="initialize(java.lang.Class, java.lang.Object, java.lang.Object, java.beans.Encoder)"><!-- --></A><H3>
initialize</H3>
<PRE>
protected void <B>initialize</B>(java.lang.Class&nbsp;type,
                          java.lang.Object&nbsp;oldInstance,
                          java.lang.Object&nbsp;newInstance,
                          <A HREF="../../java/beans/Encoder.html">Encoder</A>&nbsp;out)</PRE>
<DL>
<DD>Produce a series of statements with side effects on <code>newInstance</code> 
 so that the new instance becomes <em>equivalent</em> to <code>oldInstance</code>. 
 In the specification of this method, we mean by equivalent that, after the method 
 returns, the modified instance is indistinguishable from  
 <code>newInstance</code> in the behavior of all methods in its 
 public API. 
 <p>
 The implementation typically achieves this goal by producing a series of 
 "what happened" statements involving the <code>oldInstance</code> 
 and its publicly available state. These statements are sent 
 to the output stream using its <code>writeExpression</code> 
 method which returns an expression involving elements in 
 a cloned environment simulating the state of an input stream during 
 reading. Each statement returned will have had all instances 
 the old environment replaced with objects which exist in the new 
 one. In particular, references to the target of these statements, 
 which start out as references to <code>oldInstance</code> are returned 
 as references to the <code>newInstance</code> instead. 
 Executing these statements effects an incremental 
 alignment of the state of the two objects as a series of 
 modifications to the objects in the new environment. 
 By the time the initialize method returns it should be impossible 
 to tell the two instances apart by using their public APIs. 
 Most importantly, the sequence of steps that were used to make 
 these objects appear equivalent will have been recorded 
 by the output stream and will form the actual output when 
 the stream is flushed. 
 <p> 
 The default implementation, calls the <code>initialize</code> 
 method of the type's superclass and all its interfaces.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldInstance</CODE> - The instance to be copied.<DD><CODE>newInstance</CODE> - The instance that is to be modified.<DD><CODE>out</CODE> - The stream to which any initialization statements should be written.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../java/beans/Expression.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../java/beans/Statement.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PersistenceDelegate.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
